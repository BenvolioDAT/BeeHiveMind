'use strict';
/** 
 * role.BeeWorker ‚Äì consolidated worker roles.
 * Generated by combining BaseHarvest, Builder, Courier, Queen, Upgrader
 * into one module so future refactors can drop the legacy files.
 */

var BeeToolbox = require('BeeToolbox');
// External selectors module; see BeeSelectors.js for source/sink scans.
var BeeSelectors = require('BeeSelectors');
// Shared action wrappers with movement intents.
var BeeActions = require('BeeActions');
// Central movement queue; roleQueen enqueues idles here.
var MovementManager = require('Movement.Manager');

// Shared debug + tuning config
var CFG = Object.freeze({
  // --- Pathing (used by Courier & any others that want it) ---
  PATH_REUSE: 40,
  MAX_OPS_MOVE: 2000,
  TRAVEL_MAX_OPS: 4000,
  //--- Pathing (used by Queen)----
  STUCK_TICKS: 6,
  MOVE_PRIORITIES: {
    withdraw: 60,
    pickup: 70,
    deliver: 55,
    idle: 5
    },
  // --- Targeting cadences (Courier) ---
  RETARGET_COOLDOWN: 10,
  GRAVE_SCAN_COOLDOWN: 20,
  BETTER_CONTAINER_DELTA: 150,

  // --- Thresholds / radii (Courier) ---
  CONTAINER_MIN: 50,
  DROPPED_BIG_MIN: 150,
  DROPPED_NEAR_CONTAINER_R: 2,
  DROPPED_ALONG_ROUTE_R: 2,

  // --- Towers (Courier) ---
  TOWER_REFILL_AT_OR_BELOW: 0.70,

  // --- Debug toggles (shared) ---
  DEBUG_SAY: false,
  DEBUG_DRAW: true,

  // --- Visual styles (shared) ---
  DRAW: {
    // BaseHarvest-style visuals
    TRAVEL:   "#8ab6ff",
    SOURCE:   "#ffd16e",
    SEAT:     "#6effa1",
    QUEUE:    "#ffe66e",
    YIELD:    "#ff6e6e",
    OFFLOAD:  "#6ee7ff",
    IDLE:     "#bfbfbf",

    // Courier-style visuals
    WD_COLOR:    "#6ec1ff",  // withdraw lines
    FILL_COLOR:  "#6effa1",  // delivery lines
    DROP_COLOR:  "#ffe66e",  // dropped energy
    GRAVE_COLOR: "#ffb0e0",  // tombstones/ruins
    IDLE_COLOR:  "#bfbfbf",

    // Shared
    WIDTH:   0.12,
    OPACITY: 0.45,
    FONT:    0.6
  }
});

// Namespace
var roleBeeWorker = {};


/**
 * role.BeeWorker ‚Äì consolidated worker roles.
 * Generated by combining BaseHarvest, Builder, Courier, Queen, Upgrader into
 * one module so future refactors can drop the legacy files.
 */
var roleBeeWorker = {};

roleBeeWorker.BaseHarvest = (function () {


  /** =========================
   *  Debug UI toggles & styling
   *  ========================= */
 /* var CFG = Object.freeze({
    DEBUG_SAY: false,    // creep.say breadcrumbs
    DEBUG_DRAW: true,   // RoomVisual lines/labels/rings
    DRAW: {
      TRAVEL:   "#8ab6ff",
      SOURCE:   "#ffd16e",
      SEAT:     "#6effa1",
      QUEUE:    "#ffe66e",
      YIELD:    "#ff6e6e",
      OFFLOAD:  "#6ee7ff",
      IDLE:     "#bfbfbf",
      WIDTH: 0.12,
      OPACITY: 0.45,
      FONT: 0.6
    }
  });*/

  /** =========================
   *  Config knobs
   *  ========================= */
  var CONFIG = {
    maxHarvestersPerSource: 1,   // 1 = strict single-seat miners (best w/ container)
    avoidTicksAfterYield: 20,    // loser avoids yielded source for this many ticks
    handoffTtl: 120,             // if incumbent's TTL <= this, allow queueing
    queueRange: 2,               // (kept for semantics; queue finder picks tiles around seat)
    travelReuse: 12              // reusePath hint for travel helper
  };

  /** =========================
   *  Debug helpers
   *  ========================= */
  function debugSay(creep, msg) {
    if (CFG.DEBUG_SAY && creep && msg) creep.say(msg, true);
  }
  function _posOf(target) {
    if (!target) return null;
    if (target.pos) return target.pos;
    if (target.x != null && target.y != null && target.roomName) return target;
    return null;
  }
  function debugDrawLine(creep, target, color, label) {
    if (!CFG.DEBUG_DRAW || !creep || !target) return;
    var room = creep.room; if (!room || !room.visual) return;
    var tpos = _posOf(target); if (!tpos || tpos.roomName !== room.name) return;
    try {
      room.visual.line(creep.pos, tpos, {
        color: color, width: CFG.DRAW.WIDTH, opacity: CFG.DRAW.OPACITY, lineStyle: "solid"
      });
      if (label) {
        room.visual.text(label, tpos.x, tpos.y - 0.3, {
          color: color, opacity: CFG.DRAW.OPACITY, font: CFG.DRAW.FONT, align: "center"
        });
      }
    } catch (e) {}
  }
  function debugRing(room, pos, color, text) {
    if (!CFG.DEBUG_DRAW || !room || !room.visual || !pos) return;
    try {
      room.visual.circle(pos, { radius: 0.5, fill: "transparent", stroke: color, opacity: CFG.DRAW.OPACITY, width: CFG.DRAW.WIDTH });
      if (text) room.visual.text(text, pos.x, pos.y - 0.6, { color: color, font: CFG.DRAW.FONT, opacity: CFG.DRAW.OPACITY, align: "center" });
    } catch (e) {}
  }

  /** =========================
   *  Travel helper (BeeTravel ‚Üí Traveler ‚Üí moveTo)
   *  Draws a path hint to the target.
   *  ========================= */
  function go(creep, dest, range, reuse) {
    range = (range != null) ? range : 1;
    reuse = (reuse != null) ? reuse : CONFIG.travelReuse;
    var dpos = (dest && dest.pos) ? dest.pos : dest;
    if (dpos) debugDrawLine(creep, dpos, CFG.DRAW.TRAVEL, "GO");

    try {
      if (BeeToolbox && BeeToolbox.BeeTravel) {
        BeeToolbox.BeeTravel(creep, (dest.pos || dest), { range: range, reusePath: reuse });
        return;
      }
      if (typeof creep.travelTo === 'function') {
        creep.travelTo((dest.pos || dest), { range: range, reusePath: reuse, ignoreCreeps: false, maxOps: 4000 });
        return;
      }
    } catch (e) {}
    if (creep.pos.getRangeTo(dest) > range) creep.moveTo(dest, { reusePath: reuse, maxOps: 2000 });
  }

  /** =========================
   *  Small utils
   *  ========================= */

  // Terrain walkability check (no walls, inside bounds)
  function isWalkable(pos) {
    if (!pos || !pos.roomName) return false;
    if (pos.x <= 0 || pos.x >= 49 || pos.y <= 0 || pos.y >= 49) return false;
    var t = new Room.Terrain(pos.roomName);
    return t.get(pos.x, pos.y) !== TERRAIN_MASK_WALL;
  }

  // Is the tile occupied by *another* friendly creep?
  function isTileOccupiedByAlly(pos, myName) {
    var creeps = pos.lookFor(LOOK_CREEPS);
    for (var i = 0; i < creeps.length; i++) {
      var c = creeps[i];
      if (c.my && c.name !== myName) return true;
    }
    return false;
  }

  // Is the tile occupied by ANY creep (ally or not), excluding me?
  function isTileOccupiedByAnyCreep(pos, myName) {
    var creeps = pos.lookFor(LOOK_CREEPS);
    for (var i = 0; i < creeps.length; i++) {
      var c = creeps[i];
      if (!c) continue;
      if (!myName || c.name !== myName) return true;
    }
    return false;
  }

  // Count how many walkable seats around a pos (8-neighborhood)
  function countWalkableSeatsAround(pos) {
    var seats = 0;
    var t = new Room.Terrain(pos.roomName);
    for (var dx = -1; dx <= 1; dx++) {
      for (var dy = -1; dy <= 1; dy++) {
        if (dx === 0 && dy === 0) continue;
        var x = pos.x + dx, y = pos.y + dy;
        if (x <= 0 || x >= 49 || y <= 0 || y >= 49) continue;
        if (t.get(x, y) !== TERRAIN_MASK_WALL) seats++;
      }
    }
    return seats;
  }

  // Find any container in range 1 of the source
  function getAdjacentContainerForSource(source) {
    var arr = source.pos.findInRange(FIND_STRUCTURES, 1, {
      filter: function (s) { return s.structureType === STRUCTURE_CONTAINER; }
    });
    return (arr && arr.length) ? arr[0] : null;
  }

  // Prefer container tile as the "seat". Else pick a deterministic adjacent tile.
  function getPreferredSeatPos(source) {
    var cont = getAdjacentContainerForSource(source);
    if (cont) return cont.pos;

    // No container: choose a stable walkable tile (sorted by y then x)
    var candidates = [];
    for (var dx = -1; dx <= 1; dx++) {
      for (var dy = -1; dy <= 1; dy++) {
        if (dx === 0 && dy === 0) continue;
        var p = new RoomPosition(source.pos.x + dx, source.pos.y + dy, source.pos.roomName);
        if (isWalkable(p)) candidates.push(p);
      }
    }
    if (!candidates.length) return null;
    candidates.sort(function(a, b) { return (a.y - b.y) || (a.x - b.x); });
    return candidates[0];
  }

  function matchesRole(creep, roleName, legacyTask) {
    if (!creep || !creep.memory) return false;
    var role = creep.memory.role;
    if (role && roleName && String(role).toLowerCase() === String(roleName).toLowerCase()) return true;
    var bornRole = creep.memory.bornRole;
    if (bornRole && roleName && String(bornRole).toLowerCase() === String(roleName).toLowerCase()) return true;
    var task = creep.memory.task;
    var legacy = legacyTask || roleName;
    if (task && legacy && String(task).toLowerCase() === String(legacy).toLowerCase()) return true;
    if (task && roleName && String(task).toLowerCase() === String(roleName).toLowerCase()) return true;
    return false;
  }

  // Any friendly harvesters currently assigned to this source (live only)
  function getIncumbents(roomName, sourceId, excludeName) {
    var out = [];
    for (var name in Game.creeps) {
      var c = Game.creeps[name];
      if (!c || !c.my) continue;
      if (excludeName && name === excludeName) continue;
      if (c.memory && matchesRole(c, 'BaseHarvest', 'baseharvest') &&
          c.memory.assignedSource === sourceId &&
          c.room && c.room.name === roomName) {
        out.push(c);
      }
    }
    return out;
  }

  // Count assigned harvesters (live)
  function countAssignedHarvesters(roomName, sourceId) {
    return getIncumbents(roomName, sourceId, null).length;
  }

  /** =========================
   *  Conflict / yield logic
   *  ========================= */

  // Adjacent conflict resolver: stable winner by name; loser yields & avoids briefly.
  function resolveSourceConflict(creep, source) {
    var neighbors = source.pos.findInRange(FIND_MY_CREEPS, 1, {
      filter: function(c) {
        return c.name !== creep.name &&
               matchesRole(c, 'BaseHarvest', 'baseharvest') &&
               c.memory.assignedSource === source.id;
      }
    });

    if (neighbors.length === 0) return false;

    // If I'm effectively the only assigned miner left (others died), don't yield.
    if (countAssignedHarvesters(creep.room.name, source.id) <= 1) return false;

    var all = neighbors.concat([creep]);
    var winner = all[0];
    for (var i = 1; i < all.length; i++) {
      if (all[i].name < winner.name) winner = all[i];
    }

    if (winner.name !== creep.name) {
      creep.memory._avoidSourceId = source.id;
      creep.memory._avoidUntil    = Game.time + CONFIG.avoidTicksAfterYield;
      creep.memory.assignedSource = null;
      creep.memory._reassignCooldown = Game.time + 5;
      creep.memory.waitingForSeat = false;

      debugSay(creep, 'yield üêù');
      debugRing(creep.room, source.pos, CFG.DRAW.YIELD, "YIELD");
      return true;
    }
    return false;
  }

  /** =========================
   *  Queue / handoff logic
   *  ========================= */

  // Return true if we should queue: source is at capacity but an incumbent is expiring soon.
  function shouldQueueForSource(creep, source, seats, used) {
    if (used < seats) return false; // not full
    var inc = getIncumbents(creep.room.name, source.id, creep.name);
    for (var i = 0; i < inc.length; i++) {
      var t = inc[i].ticksToLive;
      if (typeof t === 'number' && t <= CONFIG.handoffTtl) return true;
    }
    return false;
  }

  // Pick a queue spot near the seat (not on the seat), walkable & (ideally) unoccupied.
  function findQueueSpotNearSeat(seatPos, myName) {
    var best = null, bestScore = -Infinity;
    for (var dx = -1; dx <= 1; dx++) {
      for (var dy = -1; dy <= 1; dy++) {
        if (dx === 0 && dy === 0) continue;
        var p = new RoomPosition(seatPos.x + dx, seatPos.y + dy, seatPos.roomName);
        if (!isWalkable(p)) continue;
        var occupied = isTileOccupiedByAlly(p, myName);
        var score = occupied ? -10 : 0;
        score += (-p.y * 0.01) + (-p.x * 0.001);
        if (score > bestScore) { bestScore = score; best = p; }
      }
    }
    return best;
  }

  /** =========================
   *  Source assignment
   *  ========================= */

  function assignSource(creep) {
    if (creep.spawning) return;

    if (creep.memory._reassignCooldown && Game.time < creep.memory._reassignCooldown) {
      return creep.memory.assignedSource || null;
    }

    if (creep.memory.assignedSource) return creep.memory.assignedSource;

    var sources = creep.room.find(FIND_SOURCES);
    if (!sources || !sources.length) return null;

    var best = null;
    var bestScore = -Infinity;
    var bestWillQueue = false;

    for (var i = 0; i < sources.length; i++) {
      var s = sources[i];

      if (creep.memory._avoidSourceId === s.id &&
          creep.memory._avoidUntil &&
          Game.time < creep.memory._avoidUntil) {
        continue;
      }

      var seatPos = getPreferredSeatPos(s);
      if (!seatPos) continue;

      var seats = getAdjacentContainerForSource(s) ? 1 : countWalkableSeatsAround(s.pos);
      if (CONFIG.maxHarvestersPerSource > 0) {
        seats = Math.min(seats, CONFIG.maxHarvestersPerSource);
      }

      var used = countAssignedHarvesters(creep.room.name, s.id);
      var free = seats - used;
      var willQueue = false;

      if (free <= 0) {
        if (!shouldQueueForSource(creep, s, seats, used)) continue;
        willQueue = true;
      }

      var range = creep.pos.getRangeTo(seatPos);
      var score = (free > 0 ? 1000 : 0) - range;

      if (score > bestScore) {
        bestScore = score;
        best = { source: s, seatPos: seatPos };
        bestWillQueue = willQueue;
      }
    }

    if (!best) return null;

    creep.memory.assignedSource = best.source.id;
    creep.memory.seatX = best.seatPos.x;
    creep.memory.seatY = best.seatPos.y;
    creep.memory.seatRoom = best.seatPos.roomName;
    creep.memory.waitingForSeat = !!bestWillQueue;

    debugSay(creep, bestWillQueue ? '‚è≥' : 'üéØ');
    debugRing(creep.room, best.source.pos, CFG.DRAW.SOURCE, "SRC");
    debugRing(creep.room, best.seatPos,   CFG.DRAW.SEAT,   "SEAT");

    return best.source.id;
  }

  /** =========================
   *  Offload helpers (when full)
   *  ========================= */

  function getContainerAtOrAdjacent(pos) {
    var here = pos.lookFor(LOOK_STRUCTURES);
    for (var i = 0; i < here.length; i++) {
      if (here[i].structureType === STRUCTURE_CONTAINER) return here[i];
    }
    var around = pos.findInRange(FIND_STRUCTURES, 1, {
      filter: function(s) { return s.structureType === STRUCTURE_CONTAINER; }
    });
    return (around && around.length) ? around[0] : null;
  }

  function countCreepsWithRole(roleName, legacyTask) {
    var n = 0;
    for (var name in Game.creeps) {
      var c = Game.creeps[name];
      if (c && matchesRole(c, roleName, legacyTask)) n++;
    }
    return n;
  }

  // Prefer returning to spawn/extensions; fallback to storage; then any container.
  function findEmergencyEnergySink(creep) {
    var spawn = creep.pos.findClosestByPath(FIND_MY_STRUCTURES, {
      filter: function(s) {
        return s.structureType === STRUCTURE_SPAWN &&
               s.store && s.store.getFreeCapacity(RESOURCE_ENERGY) > 0;
      }
    });
    if (spawn) return spawn;

    var ext = creep.pos.findClosestByPath(FIND_MY_STRUCTURES, {
      filter: function(s) {
        return s.structureType === STRUCTURE_EXTENSION &&
               s.store && s.store.getFreeCapacity(RESOURCE_ENERGY) > 0;
      }
    });
    if (ext) return ext;

    if (creep.room.storage && creep.room.storage.store &&
        creep.room.storage.store.getFreeCapacity(RESOURCE_ENERGY) > 0) {
      return creep.room.storage;
    }

    var cont = creep.pos.findClosestByPath(FIND_STRUCTURES, {
      filter: function(s) {
        return s.structureType === STRUCTURE_CONTAINER &&
               s.store && s.store.getFreeCapacity(RESOURCE_ENERGY) > 0;
      }
    });
    if (cont) return cont;

    return null;
  }

  /** =========================
   *  Main role
   *  ========================= */

  // Teaching helper: novice readers can follow the role flow by calling these in order.
  function ensureRoleIdentity(creep) {
    if (!creep || !creep.memory) return;
    if (!creep.memory.role || String(creep.memory.role).toLowerCase() === 'baseharvest') {
      creep.memory.role = 'BaseHarvest';
    }
    if (!creep.memory.task) creep.memory.task = 'baseharvest';
  }

  function updateHarvestingFlag(creep) {
    if (!creep) return false;
    var empty = creep.store.getUsedCapacity(RESOURCE_ENERGY) === 0;
    var full  = creep.store.getFreeCapacity(RESOURCE_ENERGY) === 0;
    if (empty && !creep.memory.harvesting) { creep.memory.harvesting = true; debugSay(creep, '‚§µÔ∏èMINE'); }
    else if (full && creep.memory.harvesting) { creep.memory.harvesting = false; debugSay(creep, '‚§¥Ô∏èDROP'); }
    return creep.memory.harvesting;
  }

  function runHarvestPhase(creep) {
    var sid = assignSource(creep);
    if (!sid) { debugSay(creep, '‚ùì'); return; }

    var source = Game.getObjectById(sid);
    if (!source) {
      creep.memory.assignedSource = null; creep.memory.waitingForSeat = false;
      return;
    }

    // Resolve local conflicts if we are in the scrum
    if (resolveSourceConflict(creep, source)) return;

    // Preferred seat position (rebuild if memory room mismatch)
    var seatPos = (creep.memory.seatRoom === creep.room.name)
      ? new RoomPosition(creep.memory.seatX, creep.memory.seatY, creep.memory.seatRoom)
      : getPreferredSeatPos(source);

    if (seatPos) {
      debugRing(creep.room, seatPos, CFG.DRAW.SEAT, "SEAT");
    }

    // Capacity math
    var seats = getAdjacentContainerForSource(source) ? 1 : countWalkableSeatsAround(source.pos);
    if (CONFIG.maxHarvestersPerSource > 0) seats = Math.min(seats, CONFIG.maxHarvestersPerSource);
    var used  = countAssignedHarvesters(creep.room.name, source.id);

    // Promote out of queue ASAP if capacity exists now
    if (used < seats) {
      creep.memory.waitingForSeat = false;
    }

    // Seat occupancy: any creep (ally or not) blocks the exact tile unless it's me
    var seatBlocked = seatPos ? (isTileOccupiedByAnyCreep(seatPos, creep.name) && !creep.pos.isEqualTo(seatPos)) : false;

    // Decide whether to queue this tick
    var shouldQ = (seatBlocked || creep.memory.waitingForSeat) && used >= seats && shouldQueueForSource(creep, source, seats, used);

    if (shouldQ) {
      var queueSpot = findQueueSpotNearSeat(seatPos, creep.name) || seatPos;
      creep.memory.waitingForSeat = true;

      debugSay(creep, '‚è≥');
      debugRing(creep.room, queueSpot, CFG.DRAW.QUEUE, "QUEUE");
      if (!creep.pos.isEqualTo(queueSpot)) { go(creep, queueSpot, 0, CONFIG.travelReuse); return; }

      if (creep.pos.getRangeTo(source) <= 1) {
        debugDrawLine(creep, source, CFG.DRAW.SOURCE, "HARV");
        creep.harvest(source);
      }

      if (!isTileOccupiedByAnyCreep(seatPos, creep.name) || countAssignedHarvesters(creep.room.name, source.id) < seats) {
        go(creep, seatPos, 0, CONFIG.travelReuse);
        creep.memory.waitingForSeat = false;
      }
      return;
    }

    // NO QUEUE: seat free or capacity available ‚Üí go sit or harvest
    if (seatPos && !creep.pos.isEqualTo(seatPos)) {
      debugSay(creep, 'ü™ë');
      go(creep, seatPos, 0, CONFIG.travelReuse);
      return;
    }
    creep.memory.waitingForSeat = false;

    // --- Same-tick dump+harvest ONLY if collectors exist ---
    var courierCount = countCreepsWithRole('Courier', 'courier');
    var queenCount   = countCreepsWithRole('Queen', 'queen');
    var haveCollectors = (courierCount > 0 || queenCount > 0);

    var contHere = getContainerAtOrAdjacent(creep.pos);
    if (haveCollectors && contHere && creep.pos.isEqualTo(contHere.pos)) {
      if (creep.store.getUsedCapacity(RESOURCE_ENERGY) > 0) {
        var tr = creep.transfer(contHere, RESOURCE_ENERGY);
        if (tr === ERR_FULL) { debugSay(creep, '‚¨áÔ∏è'); creep.drop(RESOURCE_ENERGY); }
        else if (tr === ERR_NOT_IN_RANGE) { go(creep, contHere.pos, 0, CONFIG.travelReuse); return; }
      }
    }

    // Always swing the pick this tick
    debugSay(creep, '‚õèÔ∏è');
    debugDrawLine(creep, source, CFG.DRAW.SOURCE, "HARV");
    creep.harvest(source);
  }

  function runOffloadPhase(creep) {
    var courierCount2 = countCreepsWithRole('Courier', 'courier');
    var queenCount2   = countCreepsWithRole('Queen', 'queen');
    var haveCollectors2 = (courierCount2 > 0 || queenCount2 > 0);

    // If we DON'T have collectors, prioritize hauling to spawn/ext/storage.
    if (!haveCollectors2) {
      var sink = findEmergencyEnergySink(creep); // spawn ‚Üí ext ‚Üí storage ‚Üí container
      if (sink) {
        debugSay(creep, 'üè†');
        debugDrawLine(creep, sink, CFG.DRAW.OFFLOAD, "RETURN");
        var rs = creep.transfer(sink, RESOURCE_ENERGY);
        if (rs === ERR_NOT_IN_RANGE) { go(creep, sink, 1, CONFIG.travelReuse); return; }
        if (rs === OK) return;
      }
      debugSay(creep, '‚¨áÔ∏è'); // absolute last resort
      creep.drop(RESOURCE_ENERGY);
      return;
    }

    // We DO have collectors ‚Üí container-first flow (fast turnaround)
    var cont = getContainerAtOrAdjacent(creep.pos);
    if (cont) {
      if (!creep.pos.isEqualTo(cont.pos)) {
        debugSay(creep, 'üì¶‚Üí');
        debugDrawLine(creep, cont, CFG.DRAW.OFFLOAD, "SEAT");
        go(creep, cont.pos, 0, CONFIG.travelReuse);
        return;
      }

      debugSay(creep, 'üì¶');
      var tr2 = creep.transfer(cont, RESOURCE_ENERGY);
      if (tr2 === OK) return;
      if (tr2 === ERR_NOT_IN_RANGE) { go(creep, cont.pos, 0, CONFIG.travelReuse); return; }

      // Container rejected (likely full). Drop to keep miner unblocked.
      debugSay(creep, '‚¨áÔ∏è');
      creep.drop(RESOURCE_ENERGY);
      return;
    }

    // No container next to us but collectors exist ‚Üí drop for pickup
    debugSay(creep, '‚¨áÔ∏è');
    debugRing(creep.room, creep.pos, CFG.DRAW.OFFLOAD, "DROP");
    creep.drop(RESOURCE_ENERGY);
  }

  function idleWhenEmpty(creep) {
    if (!creep || creep.store.getUsedCapacity(RESOURCE_ENERGY) > 0) return;
    debugSay(creep, 'üßò');
    debugRing(creep.room, creep.pos, CFG.DRAW.IDLE, "IDLE");
  }

  var roleBaseHarvest = {
    role: 'BaseHarvest',
    run: function(creep) {
      ensureRoleIdentity(creep);

      // Habit: update our state once and branch from it instead of sprinkling conditions everywhere.
      var harvesting = updateHarvestingFlag(creep);

      if (harvesting) {
        runHarvestPhase(creep);
        return;
      }

      if (creep.store.getUsedCapacity(RESOURCE_ENERGY) > 0) {
        runOffloadPhase(creep);
        return;
      }

      idleWhenEmpty(creep);
    }
  };

  return roleBaseHarvest;
})();

roleBeeWorker.Builder = (function () {
/*
  // ==============================
  // Debug UI toggles & styling
  // ==============================
  var CFG = Object.freeze({
    DEBUG_SAY: false,   // creep.say breadcrumbs
    DEBUG_DRAW: true,  // RoomVisual lines/labels
    DRAW: {
      TRAVEL_COLOR:  "#8ab6ff",
      PICKUP_COLOR:  "#ffe66e",
      WITHDRAW_COLOR:"#ffd16e",
      TOMBSTONE_COLOR:"#e6a6ff",
      RUIN_COLOR:    "#c6b3ff",
      SRC_CONT_COLOR:"#ffa36e",
      STORELIKE_COLOR:"#6ee7ff",
      BUILD_COLOR:   "#e6c16e",
      SINK_COLOR:    "#6effa1",
      IDLE_COLOR:    "#bfbfbf",
      WIDTH: 0.12,
      OPACITY: 0.45,
      FONT: 0.6
    }
  });
  */

  // ==============================
  // Tunables
  // ==============================
  var ALLOW_HARVEST_FALLBACK = false; // flip true if you really want last-resort mining
  var PICKUP_MIN = 50;                // ignore tiny crumbs
  var SRC_CONTAINER_MIN = 100;        // minimum energy to bother at source containers

  // ==============================
  // Debug helpers
  // ==============================
  function debugSay(creep, msg) {
    if (CFG.DEBUG_SAY && creep && msg) creep.say(msg, true);
  }
  function _posOf(target) {
    if (!target) return null;
    if (target.pos) return target.pos;
    if (target.x != null && target.y != null && target.roomName) return target;
    return null;
  }
  function debugDraw(creep, target, color, label) {
    if (!CFG.DEBUG_DRAW || !creep || !target) return;
    var room = creep.room; if (!room || !room.visual) return;
    var tpos = _posOf(target); if (!tpos || tpos.roomName !== room.name) return;

    try {
      room.visual.line(creep.pos, tpos, {
        color: color,
        width: CFG.DRAW.WIDTH,
        opacity: CFG.DRAW.OPACITY,
        lineStyle: "solid"
      });
      if (label) {
        room.visual.text(label, tpos.x, tpos.y - 0.3, {
          color: color,
          opacity: CFG.DRAW.OPACITY,
          font: CFG.DRAW.FONT,
          align: "center"
        });
      }
    } catch (e) {}
  }
  function debugRing(room, pos, color, text) {
    if (!CFG.DEBUG_DRAW || !room || !room.visual || !pos) return;
    try {
      room.visual.circle(pos, { radius: 0.5, fill: "transparent", stroke: color, opacity: CFG.DRAW.OPACITY, width: CFG.DRAW.WIDTH });
      if (text) room.visual.text(text, pos.x, pos.y - 0.6, { color: color, font: CFG.DRAW.FONT, opacity: CFG.DRAW.OPACITY, align: "center" });
    } catch (e) {}
  }

  // ==============================
  // Tiny movement helper
  // ==============================
  function go(creep, dest, range, reuse) {
    range = (range != null) ? range : 1;
    reuse = (reuse != null) ? reuse : 25;

    var dpos = (dest && dest.pos) ? dest.pos : dest;
    if (dpos) debugDraw(creep, dpos, CFG.DRAW.TRAVEL_COLOR, "GO");

    try {
      if (BeeToolbox && BeeToolbox.BeeTravel) {
        BeeToolbox.BeeTravel(creep, (dest.pos || dest), { range: range, reusePath: reuse });
        return;
      }
      if (typeof creep.travelTo === 'function') {
        creep.travelTo((dest.pos || dest), { range: range, reusePath: reuse, ignoreCreeps: false, maxOps: 4000 });
        return;
      }
    } catch (e) {}
    if (creep.pos.getRangeTo(dest) > range) creep.moveTo(dest, { reusePath: reuse, maxOps: 1500 });
  }

  // ==============================
  // Energy intake (prefer floor snacks)
  // ==============================
  function collectEnergy(creep) {
    // 1) Tombstones / Ruins
    var tomb = creep.pos.findClosestByRange(FIND_TOMBSTONES, { filter: function (t) { return (t.store[RESOURCE_ENERGY] | 0) > 0; } });
    if (tomb) {
      debugSay(creep, 'ü™¶');
      debugDraw(creep, tomb, CFG.DRAW.TOMBSTONE_COLOR, "TOMB");
      var tr = creep.withdraw(tomb, RESOURCE_ENERGY);
      if (tr === ERR_NOT_IN_RANGE) go(creep, tomb, 1, 20);
      return true;
    }
    var ruin = creep.pos.findClosestByRange(FIND_RUINS, { filter: function (r) { return (r.store[RESOURCE_ENERGY] | 0) > 0; } });
    if (ruin) {
      debugSay(creep, 'üèöÔ∏è');
      debugDraw(creep, ruin, CFG.DRAW.RUIN_COLOR, "RUIN");
      var rr = creep.withdraw(ruin, RESOURCE_ENERGY);
      if (rr === ERR_NOT_IN_RANGE) go(creep, ruin, 1, 20);
      return true;
    }

    // 2) Dropped
    var dropped = creep.pos.findClosestByRange(FIND_DROPPED_RESOURCES, {
      filter: function (r) { return r.resourceType === RESOURCE_ENERGY && (r.amount | 0) >= PICKUP_MIN; }
    });
    if (dropped) {
      debugSay(creep, 'üç™');
      debugDraw(creep, dropped, CFG.DRAW.PICKUP_COLOR, "DROP");
      if (creep.pickup(dropped) === ERR_NOT_IN_RANGE) go(creep, dropped, 1, 15);
      return true;
    }

    // 3) Source-adjacent container
    var srcCont = creep.pos.findClosestByRange(FIND_STRUCTURES, {
      filter: function (s) {
        if (s.structureType !== STRUCTURE_CONTAINER || !s.store) return false;
        if (s.pos.findInRange(FIND_SOURCES, 1).length === 0) return false;
        return (s.store[RESOURCE_ENERGY] | 0) >= SRC_CONTAINER_MIN;
      }
    });
    if (srcCont) {
      debugSay(creep, 'üì¶');
      debugDraw(creep, srcCont, CFG.DRAW.SRC_CONT_COLOR, "SRC‚Ä¢CONT");
      var cr = creep.withdraw(srcCont, RESOURCE_ENERGY);
      if (cr === ERR_NOT_IN_RANGE) go(creep, srcCont, 1, 25);
      return true;
    }

    // 4) Any store (container/link/storage/terminal)
    var storeLike = creep.pos.findClosestByRange(FIND_STRUCTURES, {
      filter: function (s) {
        if (!s.store) return false;
        var t = s.structureType;
        if (t !== STRUCTURE_CONTAINER && t !== STRUCTURE_LINK && t !== STRUCTURE_STORAGE && t !== STRUCTURE_TERMINAL) return false;
        return (s.store[RESOURCE_ENERGY] | 0) > 0;
      }
    });
    if (storeLike) {
      debugSay(creep, 'üè¶');
      debugDraw(creep, storeLike, CFG.DRAW.STORELIKE_COLOR, "WITHDRAW");
      var sr = creep.withdraw(storeLike, RESOURCE_ENERGY);
      if (sr === ERR_NOT_IN_RANGE) go(creep, storeLike, 1, 25);
      return true;
    }

    // 5) Optional last resort: harvest
    if (ALLOW_HARVEST_FALLBACK) {
      var src = creep.pos.findClosestByRange(FIND_SOURCES_ACTIVE);
      if (src) {
        debugSay(creep, '‚õèÔ∏è');
        debugDraw(creep, src, CFG.DRAW.SRC_CONT_COLOR, "MINE");
        var hr = creep.harvest(src);
        if (hr === ERR_NOT_IN_RANGE) go(creep, src, 1, 20);
        return true;
      }
    }

    // Idle near something useful
    var anchor = creep.room.storage || creep.pos.findClosestByRange(FIND_MY_SPAWNS) || creep.pos;
    if (anchor && anchor.pos) {
      debugSay(creep, 'üßò');
      debugDraw(creep, anchor, CFG.DRAW.IDLE_COLOR, "IDLE");
      go(creep, anchor, 2, 20);
    }
    return false;
  }

  function toggleBuilderState(creep) {
    if (creep.memory.building && creep.store[RESOURCE_ENERGY] === 0) {
      creep.memory.building = false;
      debugSay(creep, '‚§µÔ∏èREFUEL');
    }
    if (!creep.memory.building && creep.store.getFreeCapacity() === 0) {
      creep.memory.building = true;
      debugSay(creep, '‚§¥Ô∏èBUILD');
    }
  }

  function idleNearAnchor(creep) {
    var anchor = creep.room.storage || creep.pos.findClosestByRange(FIND_MY_SPAWNS) || creep.pos;
    if (anchor && anchor.pos) {
      debugSay(creep, 'üßò');
      debugDraw(creep, anchor, CFG.DRAW.IDLE_COLOR, "IDLE");
      go(creep, anchor, 2, 20);
    }
  }

  function dumpEnergyToSink(creep) {
    if ((creep.store[RESOURCE_ENERGY] | 0) <= 0) return false;
    var sink = creep.pos.findClosestByRange(FIND_STRUCTURES, {
      filter: function (s) {
        if (!s.store) return false;
        return (s.store.getFreeCapacity(RESOURCE_ENERGY) | 0) > 0 &&
               (s.structureType === STRUCTURE_STORAGE   ||
                s.structureType === STRUCTURE_TERMINAL  ||
                s.structureType === STRUCTURE_SPAWN     ||
                s.structureType === STRUCTURE_EXTENSION ||
                s.structureType === STRUCTURE_TOWER     ||
                s.structureType === STRUCTURE_CONTAINER ||
                s.structureType === STRUCTURE_LINK);
      }
    });
    if (!sink) return false;
    debugSay(creep, '‚û°Ô∏èSINK');
    debugDraw(creep, sink, CFG.DRAW.SINK_COLOR, "SINK");
    if (creep.transfer(sink, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) go(creep, sink, 1, 20);
    return true;
  }

  function runBuildPhase(creep) {
    var site = pickBuildSite(creep);
    if (site) {
      if (doBuild(creep, site)) return;
      if ((creep.store[RESOURCE_ENERGY] | 0) === 0) creep.memory.building = false;
      else creep.memory.siteId = null;
      return;
    }

    if (dumpEnergyToSink(creep)) return;
    idleNearAnchor(creep);
  }

  // ==============================
  // Pick a build target (simple + sticky)
  // ==============================
  function pickBuildSite(creep) {
    // sticky
    var id = creep.memory.siteId;
    if (id) {
      var stick = Game.constructionSites[id];
      if (stick) {
        debugRing(creep.room, stick.pos, CFG.DRAW.BUILD_COLOR, "STICK");
        return stick;
      }
      creep.memory.siteId = null;
    }

    // prefer current room
    var local = creep.room.find(FIND_CONSTRUCTION_SITES);
    if (local.length) {
      // light priority: spawn/ext/tower first, else nearest
      var prio = { 'spawn': 5, 'extension': 4, 'tower': 3, 'container': 2, 'road': 1 };
      var best = null, bestScore = -1, bestD = 1e9;
      for (var i = 0; i < local.length; i++) {
        var s = local[i], sc = (prio[s.structureType] | 0), d = creep.pos.getRangeTo(s.pos);
        if (sc > bestScore || (sc === bestScore && d < bestD)) { best = s; bestScore = sc; bestD = d; }
      }
      if (best) {
        creep.memory.siteId = best.id;
        debugRing(creep.room, best.pos, CFG.DRAW.BUILD_COLOR, best.structureType.toUpperCase());
        return best;
      }
    }

    // otherwise, nearest room with a site (visible or not)
    var any = null, bestDist = 1e9;
    for (var sid in Game.constructionSites) {
      if (!Game.constructionSites.hasOwnProperty(sid)) continue;
      var s2 = Game.constructionSites[sid];
      var d2 = Game.map.getRoomLinearDistance(creep.pos.roomName, s2.pos.roomName);
      if (d2 < bestDist) { bestDist = d2; any = s2; }
    }
    if (any) { creep.memory.siteId = any.id; debugRing(creep.room, any.pos, CFG.DRAW.BUILD_COLOR, "NEAR"); return any; }

    return null;
  }

  // ==============================
  // Build work
  // ==============================
  function doBuild(creep, site) {
    if (!site) return false;

    if (creep.pos.inRangeTo(site.pos, 3)) {
      debugSay(creep, 'üî®');
      debugDraw(creep, site, CFG.DRAW.BUILD_COLOR, "BUILD");
      var r = creep.build(site);
      if (r === ERR_NOT_ENOUGH_RESOURCES) return false;
      if (r === ERR_INVALID_TARGET) { creep.memory.siteId = null; return false; }
      return true;
    }

    debugDraw(creep, site, CFG.DRAW.TRAVEL_COLOR, "TO‚Ä¢SITE");
    go(creep, site, 3, 15);
    return true;
  }

  // ==============================
  // Public API
  // ==============================
  var roleBuilder = {
    role: 'Builder',
    run: function (creep) {
      toggleBuilderState(creep);

      if (creep.memory.building) {
        runBuildPhase(creep);
        return;
      }

      // Refuel phase (no mining unless allowed)
      collectEnergy(creep);
    }
  };

  return roleBuilder;
})();

roleBeeWorker.Courier = (function () {
  // role.Courier ‚Äì Energy hauler (ES5-safe) with SAY + DRAW breadcrumbs
  // Collect priority: Source CONTAINER -> big DROPS (en route) -> drops NEAR container -> GRAVES/RUINS -> misc DROPS -> STORAGE/TERMINAL
  // Deliver priority: SPAWNS/EXTENSIONS -> TOWERS (<= pct) -> STORAGE
  //
  // Shares PIB + same-tick reservation scheme with Queen to avoid target dogpiles.
/*
  // ============================
  // Tunables
  // ============================
  var CFG = Object.freeze({
    // Pathing
    PATH_REUSE: 40,
    MAX_OPS_MOVE: 2000,
    TRAVEL_MAX_OPS: 4000,

    // Targeting cadences
    RETARGET_COOLDOWN: 10,          // ticks before switching pickup container
    GRAVE_SCAN_COOLDOWN: 20,        // room-level cooldown for tombstone/ruin scans
    BETTER_CONTAINER_DELTA: 150,    // how much more energy makes a source container "clearly better"

    // Thresholds / radii
    CONTAINER_MIN: 50,              // ignore tiny trickles in containers
    DROPPED_BIG_MIN: 150,           // opportunistic pickup threshold
    DROPPED_NEAR_CONTAINER_R: 2,    // radius around source container
    DROPPED_ALONG_ROUTE_R: 2,       // radius around the creep while traveling

    // Towers
    TOWER_REFILL_AT_OR_BELOW: 0.70, // refill towers when <= 70%

    // Debug UI
    DEBUG_SAY: false,                // creep.say breadcrumbs
    DEBUG_DRAW: true,               // RoomVisual lines + labels
    DRAW: {
      WD_COLOR: "#6ec1ff",          // withdraw lines
      FILL_COLOR: "#6effa1",        // delivery lines
      DROP_COLOR: "#ffe66e",        // dropped energy
      GRAVE_COLOR: "#ffb0e0",       // tombstones/ruins
      IDLE_COLOR: "#bfbfbf",        // idle
      WIDTH: 0.12,
      OPACITY: 0.45,
      FONT: 0.6
    }
  });
  */

  // ============================
  // Per-tick room cache
  // ============================
  if (!global.__COURIER) global.__COURIER = { tick: -1, rooms: {} };

  function _roomCache(room) {
    var G = global.__COURIER;
    if (G.tick !== Game.time) {
      G.tick = Game.time;
      G.rooms = {};
    }
    var R = G.rooms[room.name];
    if (R) return R;

    var containers = room.find(FIND_STRUCTURES, {
      filter: function (s) { return s.structureType === STRUCTURE_CONTAINER; }
    });

    var srcIds = [];
    var otherIds = [];
    var bestId = null;
    var bestEnergy = -1;

    for (var i = 0; i < containers.length; i++) {
      var c = containers[i];
      var isSrc = c.pos.findInRange(FIND_SOURCES, 1).length > 0;
      var energy = (c.store && c.store[RESOURCE_ENERGY]) || 0;

      if (isSrc) {
        srcIds.push(c.id);
        if (energy > bestEnergy) {
          bestEnergy = energy;
          bestId = c.id;
        }
      } else {
        otherIds.push(c.id);
      }
    }

    R = {
      srcIds: srcIds,                 // ids of source-adjacent containers
      otherIds: otherIds,             // ids of non-source containers (rarely used here)
      bestSrcId: bestId,
      bestSrcEnergy: bestEnergy,
      nextGraveScanAt: (Game.time + 1),
      graves: []                      // tombstones/ruins with energy
    };
    G.rooms[room.name] = R;
    return R;
  }

  function _idsToObjects(ids) {
    var out = [];
    for (var i = 0; i < ids.length; i++) {
      var o = Game.getObjectById(ids[i]);
      if (o) out.push(o);
    }
    return out;
  }

  // ============================
  // Movement + tiny utils (ES5-safe)
  // ============================
  function go(creep, dest, range, reuse) {
    range = (range != null) ? range : 1;
    reuse = (reuse != null) ? reuse : CFG.PATH_REUSE;

    // Traveler first (preferred)
    if (creep.travelTo) {
      var tOpts = {
        range: range,
        reusePath: reuse,
        ignoreCreeps: false,
        stuckValue: 2,
        repath: 0.05,
        maxOps: CFG.TRAVEL_MAX_OPS
      };
      if (BeeToolbox && BeeToolbox.roomCallback) tOpts.roomCallback = BeeToolbox.roomCallback;
      creep.travelTo((dest.pos || dest), tOpts);
      return;
    }

    // Fallback
    if (creep.pos.getRangeTo(dest) > range) {
      creep.moveTo(dest, { reusePath: reuse, maxOps: CFG.MAX_OPS_MOVE });
    }
  }

  function debugSay(creep, msg) {
    if (CFG.DEBUG_SAY) creep.say(msg, true);
  }

  function debugDraw(creep, target, color, label) {
    if (!CFG.DEBUG_DRAW || !creep || !target) return;
    var room = creep.room;
    if (!room || !room.visual) return;

    var tpos = target.pos || target.position;
    if (!tpos || tpos.roomName !== room.name) return;

    try {
      room.visual.line(creep.pos, tpos, {
        color: color,
        width: CFG.DRAW.WIDTH,
        opacity: CFG.DRAW.OPACITY,
        lineStyle: "solid"
      });
      if (label) {
        room.visual.text(label, tpos.x, tpos.y - 0.3, {
          color: color,
          opacity: CFG.DRAW.OPACITY,
          font: CFG.DRAW.FONT,
          align: "center"
        });
      }
    } catch (e) {}
  }

  function isGoodContainer(c) {
    return c && c.structureType === STRUCTURE_CONTAINER &&
           c.store && ((c.store[RESOURCE_ENERGY] | 0) >= CFG.CONTAINER_MIN);
  }

  function _closestByRange(pos, arr) {
    var best = null, bestD = 1e9;
    for (var i = 0; i < arr.length; i++) {
      var o = arr[i];
      var d = pos.getRangeTo(o);
      if (d < bestD) { bestD = d; best = o; }
    }
    return best;
  }

  function _energyOf(c) {
    return (c && c.store && c.store[RESOURCE_ENERGY]) | 0;
  }

  function _clearlyBetter(a, b) {
    var ae = _energyOf(a);
    var be = _energyOf(b);
    return ae > (be + CFG.BETTER_CONTAINER_DELTA);
  }

  // ============================
  // PIB + same-tick reservations (shared with Queen)
  // ============================
  function _qrMap() {
    if (!Memory._queenRes || Memory._queenRes.tick !== Game.time) {
      Memory._queenRes = { tick: Game.time, map: {} };
    }
    return Memory._queenRes.map;
  }

  function _reservedFor(structId) {
    var map = _qrMap();
    return map[structId] || 0;
  }

  function _pibSumReserved(roomName, targetId, resourceType) {
    resourceType = resourceType || RESOURCE_ENERGY;
    var root = Memory._PIB;
    if (!root || root.tick == null || !root.rooms) return 0;
    var R = root.rooms[roomName];
    if (!R || !R.fills) return 0;
    var byCreep = R.fills[targetId] || {};
    var total = 0;
    for (var cname in byCreep) {
      if (!byCreep.hasOwnProperty(cname)) continue;
      var rec = byCreep[cname];
      if (!rec || rec.res !== resourceType) continue;
      if (rec.untilTick > Game.time) total += (rec.amount | 0);
    }
    return total;
  }

  function _pibRoom(roomName) {
    var root = Memory._PIB;
    if (!root || root.tick !== Game.time) {
      Memory._PIB = { tick: Game.time, rooms: root && root.rooms ? root.rooms : {} };
      root = Memory._PIB;
    }
    if (!root.rooms[roomName]) root.rooms[roomName] = { fills: {} };
    return root.rooms[roomName];
  }

  function _pibReserveFill(creep, target, amount, resourceType) {
    if (!creep || !target || !amount) return 0;
    resourceType = resourceType || RESOURCE_ENERGY;
    var roomName = (target.pos && target.pos.roomName) || (creep.room && creep.room.name);
    if (!roomName) return 0;

    var R = _pibRoom(roomName);
    if (!R.fills[target.id]) R.fills[target.id] = {};

    var dist = 0;
    try { dist = creep.pos.getRangeTo(target); } catch (e) { dist = 5; }
    var eta = Math.max(2, (dist | 0) + 1);

    R.fills[target.id][creep.name] = {
      res: resourceType,
      amount: amount | 0,
      untilTick: Game.time + eta
    };
    return amount | 0;
  }

  function _pibReleaseFill(creep, target, resourceType) {
    if (!creep || !target) return;
    resourceType = resourceType || RESOURCE_ENERGY;
    var roomName = (target.pos && target.pos.roomName) || (creep.room && creep.room.name);
    if (!roomName) return;

    var root = Memory._PIB;
    if (!root || !root.rooms) return;
    var R = root.rooms[roomName];
    if (!R || !R.fills) return;
    var map = R.fills[target.id];
    if (map && map[creep.name]) delete map[creep.name];
    if (map && Object.keys(map).length === 0) delete R.fills[target.id];
  }

  // Effective free capacity that respects reservations
  function _effectiveFree(struct, resourceType) {
    resourceType = resourceType || RESOURCE_ENERGY;
    var freeNow = (struct.store && struct.store.getFreeCapacity(resourceType)) || 0;
    var sameTick = _reservedFor(struct.id) | 0;
    var roomName = (struct.pos && struct.pos.roomName) || (struct.room && struct.room.name);
    var pib = roomName ? (_pibSumReserved(roomName, struct.id, resourceType) | 0) : 0;
    return Math.max(0, freeNow - sameTick - pib);
  }

  // Reserve up to `amount` for this creep (same-tick + PIB)
  function reserveFill(creep, target, amount, resourceType) {
    resourceType = resourceType || RESOURCE_ENERGY;
    var map = _qrMap();
    var free = _effectiveFree(target, resourceType);
    var want = Math.max(0, Math.min(amount | 0, free | 0));
    if (want > 0) {
      map[target.id] = (map[target.id] || 0) + want;
      creep.memory.dropoffId = target.id;
      _pibReserveFill(creep, target, want, resourceType);
    }
    return want;
  }

  // Transfer wrapper that releases PIB intent properly
  function transferTo(creep, target, res) {
    res = res || RESOURCE_ENERGY;
    var rc = creep.transfer(target, res);

    if (rc === ERR_NOT_IN_RANGE) { go(creep, target, 1, CFG.PATH_REUSE); return rc; }

    if (rc === OK) {
      _pibReleaseFill(creep, target, res);
    } else if (rc === ERR_FULL) {
      _pibReleaseFill(creep, target, res);
      creep.memory.dropoffId = null;
    } else if (rc !== OK && rc !== ERR_TIRED && rc !== ERR_BUSY) {
      _pibReleaseFill(creep, target, res);
      creep.memory.dropoffId = null;
    }
    return rc;
  }

  // ============================
  // Targeting helpers for DELIVERY
  // ============================
  function _pickSpawnExt(creep) {
    var list = creep.room.find(FIND_STRUCTURES, {
      filter: function (s) {
        if (!s.store) return false;
        var t = s.structureType;
        if (t !== STRUCTURE_SPAWN && t !== STRUCTURE_EXTENSION) return false;
        return _effectiveFree(s, RESOURCE_ENERGY) > 0;
      }
    });
    return list.length ? _closestByRange(creep.pos, list) : null;
  }

  function _pickTower(creep) {
    var list = creep.room.find(FIND_STRUCTURES, {
      filter: function (s) {
        if (s.structureType !== STRUCTURE_TOWER || !s.store) return false;
        var used = (s.store.getUsedCapacity(RESOURCE_ENERGY) | 0);
        var cap  = (s.store.getCapacity(RESOURCE_ENERGY) | 0);
        if (cap <= 0) return false;
        var pct = used / cap;
        if (pct > CFG.TOWER_REFILL_AT_OR_BELOW) return false; // only if low enough
        return _effectiveFree(s, RESOURCE_ENERGY) > 0;
      }
    });
    return list.length ? _closestByRange(creep.pos, list) : null;
  }

  function _pickStorage(creep) {
    var st = creep.room.storage;
    if (!st || !st.store) return null;
    if (_effectiveFree(st, RESOURCE_ENERGY) <= 0) return null;
    return st;
  }

  // ============================
  // Memory / state helpers
  // ============================
  function ensureCourierState(creep) {
    // Newer coders sometimes forget to guard both edges of the state machine.
    // We check the "cargo empty" and "cargo full" edges separately to keep it obvious
    // which condition flips us into delivery mode.
    if (creep.memory.transferring && creep.store[RESOURCE_ENERGY] === 0) {
      creep.memory.transferring = false;
    }
    if (!creep.memory.transferring && creep.store.getFreeCapacity() === 0) {
      creep.memory.transferring = true;
    }

    // Stickies default to "null" so JSON.stringify stays light and our guards stay simple.
    if (creep.memory.pickupContainerId === undefined) creep.memory.pickupContainerId = null;
    if (creep.memory.retargetAt === undefined) creep.memory.retargetAt = 0;
    if (creep.memory.dropoffId === undefined) creep.memory.dropoffId = null;
  }

  // Break collection targets into small helpers so novice contributors can trace the flow
  // without scrolling through a mega-function.
  function pickBestSourceContainer(creep, cache, now) {
    var current = Game.getObjectById(creep.memory.pickupContainerId);
    var expired = now >= (creep.memory.retargetAt | 0);
    if (isGoodContainer(current) && !expired) return current;

    var best = Game.getObjectById(cache.bestSrcId);
    if (!isGoodContainer(best)) {
      var srcObjs = _idsToObjects(cache.srcIds);
      var bestEnergy = -1;
      for (var i = 0; i < srcObjs.length; i++) {
        var c = srcObjs[i];
        var e = (c.store && c.store[RESOURCE_ENERGY]) || 0;
        if (e >= CFG.CONTAINER_MIN && e > bestEnergy) {
          best = c;
          bestEnergy = e;
        }
      }
    }

    // Only switch when the new candidate is clearly better so we do not thrash between seats.
    if (!current || (best && current.id !== best.id && _clearlyBetter(best, current))) {
      creep.memory.pickupContainerId = best ? best.id : null;
      creep.memory.retargetAt = now + CFG.RETARGET_COOLDOWN;
      return best;
    }
    return current;
  }

  function tryPickupEnRoute(creep) {
    var nearby = creep.pos.findInRange(FIND_DROPPED_RESOURCES, CFG.DROPPED_ALONG_ROUTE_R, {
      filter: function (r) { return r.resourceType === RESOURCE_ENERGY && (r.amount | 0) >= CFG.DROPPED_BIG_MIN; }
    });
    if (!nearby || !nearby.length) return false;

    var pile = _closestByRange(creep.pos, nearby);
    debugSay(creep, '‚ÜòÔ∏èDrop');
    debugDraw(creep, pile, CFG.DRAW.DROP_COLOR, "DROP*");
    if (creep.pickup(pile) === ERR_NOT_IN_RANGE) go(creep, pile, 1, 20);
    return true;
  }

  function tryContainerWorkflow(creep, container) {
    if (!isGoodContainer(container)) return false;

    // Drops near the container are low-effort fuel, so we scoop them before withdrawing.
    var drops = container.pos.findInRange(FIND_DROPPED_RESOURCES, CFG.DROPPED_NEAR_CONTAINER_R, {
      filter: function (r) { return r.resourceType === RESOURCE_ENERGY && (r.amount | 0) > 0; }
    });
    if (drops.length) {
      var bestDrop = _closestByRange(creep.pos, drops);
      debugSay(creep, '‚ÜòÔ∏èDrop');
      debugDraw(creep, bestDrop, CFG.DRAW.DROP_COLOR, "DROP");
      var pr = creep.pickup(bestDrop);
      if (pr === ERR_NOT_IN_RANGE) { go(creep, bestDrop, 1, 20); return true; }
      if (pr === OK && creep.store.getFreeCapacity() === 0) { creep.memory.transferring = true; return true; }
    }

    var energyIn = (container.store && container.store[RESOURCE_ENERGY]) | 0;
    if (energyIn <= 0) {
      creep.memory.retargetAt = Game.time;
      return false;
    }

    debugSay(creep, '‚ÜòÔ∏èCon');
    debugDraw(creep, container, CFG.DRAW.WD_COLOR, "CON");
    var wr = creep.withdraw(container, RESOURCE_ENERGY);
    if (wr === ERR_NOT_IN_RANGE) { go(creep, container, 1, CFG.PATH_REUSE); return true; }
    if (wr === OK) {
      if (creep.store.getFreeCapacity() === 0) creep.memory.transferring = true;
      return true;
    }
    if (wr === ERR_NOT_ENOUGH_RESOURCES) creep.memory.retargetAt = Game.time;
    return true;
  }

  function rescanGraves(roomCache, room) {
    if ((roomCache.nextGraveScanAt | 0) > Game.time) return;
    roomCache.nextGraveScanAt = Game.time + CFG.GRAVE_SCAN_COOLDOWN;
    var graves = room.find(FIND_TOMBSTONES, {
      filter: function (t) { return ((t.store[RESOURCE_ENERGY] | 0) > 0); }
    });
    var ruins = room.find(FIND_RUINS, {
      filter: function (r) { return ((r.store[RESOURCE_ENERGY] | 0) > 0); }
    });
    roomCache.graves = graves.concat(ruins);
  }

  function tryGraves(creep, roomCache) {
    if (!roomCache.graves || !roomCache.graves.length) return false;
    var grave = _closestByRange(creep.pos, roomCache.graves);
    if (!grave) return false;

    debugSay(creep, '‚ÜòÔ∏èGrv');
    debugDraw(creep, grave, CFG.DRAW.GRAVE_COLOR, "GRAVE");
    var gw = creep.withdraw(grave, RESOURCE_ENERGY);
    if (gw === ERR_NOT_IN_RANGE) { go(creep, grave, 1, 20); }
    return true;
  }

  function tryGenericDrops(creep) {
    var dropped = creep.pos.findClosestByRange(FIND_DROPPED_RESOURCES, {
      filter: function (r) { return r.resourceType === RESOURCE_ENERGY && (r.amount | 0) >= 50; }
    });
    if (!dropped) return false;
    debugSay(creep, '‚ÜòÔ∏èDrop');
    debugDraw(creep, dropped, CFG.DRAW.DROP_COLOR, "DROP");
    if (creep.pickup(dropped) === ERR_NOT_IN_RANGE) go(creep, dropped, 1, 20);
    return true;
  }

  function tryStorageWithdraw(creep) {
    var room = creep.room;
    var storeLike = (room.storage && (room.storage.store[RESOURCE_ENERGY] | 0) > 0) ? room.storage
                  : (room.terminal && (room.terminal.store[RESOURCE_ENERGY] | 0) > 0) ? room.terminal
                  : null;
    if (!storeLike) return false;
    debugSay(creep, storeLike.structureType === STRUCTURE_STORAGE ? '‚ÜòÔ∏èSto' : '‚ÜòÔ∏èTerm');
    debugDraw(creep, storeLike, CFG.DRAW.WD_COLOR, storeLike.structureType === STRUCTURE_STORAGE ? "STO" : "TERM");
    var sr = creep.withdraw(storeLike, RESOURCE_ENERGY);
    if (sr === ERR_NOT_IN_RANGE) { go(creep, storeLike, 1, CFG.PATH_REUSE); }
    return true;
  }

  function idleNearAnchor(creep) {
    var anchor = creep.room.storage || creep.pos.findClosestByRange(FIND_MY_SPAWNS) || creep.pos;
    debugSay(creep, 'IDLE');
    debugDraw(creep, (anchor.pos || anchor), CFG.DRAW.IDLE_COLOR, "IDLE");
    if (!creep.pos.inRangeTo(anchor, 3)) go(creep, anchor, 3, CFG.PATH_REUSE);
  }

  function ensureDropoffTarget(creep) {
    var target = Game.getObjectById(creep.memory.dropoffId);
    if (target && _effectiveFree(target, RESOURCE_ENERGY) > 0) return target;

    target = _pickSpawnExt(creep);
    if (!target) target = _pickTower(creep);
    if (!target) target = _pickStorage(creep);

    if (!target) return null;
    creep.memory.dropoffId = target.id;
    return target;
  }

  function drawDeliveryIntent(creep, target) {
    var st = target.structureType;
    if (st === STRUCTURE_EXTENSION) { debugSay(creep, '‚Üí EXT'); debugDraw(creep, target, CFG.DRAW.FILL_COLOR, "EXT"); }
    else if (st === STRUCTURE_SPAWN) { debugSay(creep, '‚Üí SPN'); debugDraw(creep, target, CFG.DRAW.FILL_COLOR, "SPN"); }
    else if (st === STRUCTURE_TOWER) { debugSay(creep, '‚Üí TWR'); debugDraw(creep, target, CFG.DRAW.FILL_COLOR, "TWR"); }
    else if (st === STRUCTURE_STORAGE) { debugSay(creep, '‚Üí STO'); debugDraw(creep, target, CFG.DRAW.FILL_COLOR, "STO"); }
    else { debugSay(creep, '‚Üí FILL'); debugDraw(creep, target, CFG.DRAW.FILL_COLOR, "FILL"); }
  }

  // ============================
  // Main role
  // ============================
  var roleCourier = {
    role: 'Courier',
    run: function (creep) {
      ensureCourierState(creep);

      if (creep.memory.transferring) {
        roleCourier.deliverEnergy(creep);
      } else {
        roleCourier.collectEnergy(creep);
      }
    },

    // -----------------------------
    // Energy collection
    // -----------------------------
    collectEnergy: function (creep) {
      var now = Game.time | 0;
      var rc = _roomCache(creep.room);
      var container = pickBestSourceContainer(creep, rc, now);

      if (tryPickupEnRoute(creep)) return;
      if (container && tryContainerWorkflow(creep, container)) return;

      rescanGraves(rc, creep.room);
      if (tryGraves(creep, rc)) return;
      if (tryGenericDrops(creep)) return;
      if (tryStorageWithdraw(creep)) return;
      idleNearAnchor(creep);
    },

    // -----------------------------
    // Delivery (PIB-aware, avoids Queen conflicts)
    // -----------------------------
    deliverEnergy: function (creep) {
      var carryAmt = (creep.store.getUsedCapacity(RESOURCE_ENERGY) | 0);
      if (carryAmt <= 0) { creep.memory.transferring = false; creep.memory.dropoffId = null; return; }

      var target = ensureDropoffTarget(creep);
      if (!target) { idleNearAnchor(creep); return; }

      var reserved = reserveFill(creep, target, carryAmt, RESOURCE_ENERGY);
      if (reserved <= 0) { creep.memory.dropoffId = null; return; }

      drawDeliveryIntent(creep, target);
      var tr = transferTo(creep, target, RESOURCE_ENERGY);
      if (tr === OK && (creep.store[RESOURCE_ENERGY] | 0) === 0) {
        creep.memory.transferring = false;
        creep.memory.dropoffId = null;
      }
    }
  };

  return roleCourier;
})();

roleBeeWorker.Queen = (function () {
  // -----------------------------------------------------------------------------
  // role.Queen.js ‚Äì economy hauler role
  // Responsibilities:
  // * Keeps a single "Queen" creep ferrying energy between sources (drops, links,
  //   tombstones, storage) and sinks (spawns/extensions/towers/storage terminals).
  // * Interacts with BeeSelectors.js for prioritised lists of energy sources and
  //   delivery targets, BeeActions.js for wrapped actions with movement, and
  //   Movement.Manager.js for centralised pathing priorities.
  // * Stores its finite-state machine in creep.memory._task (shape:
  //   {type, targetId, since, data}) and clears/refreshes it when targets change
  //   or run out of capacity.
  // * Uses global.__BHM.queenReservations to avoid multiple Queens double-booking
  //   the same sink in the same tick.
  // Called from: BeeHiveMind.runCreeps dispatcher -> roleQueen.run.
  // -----------------------------------------------------------------------------

  
  // External selectors module; see BeeSelectors.js for source/sink scans.
  //var BeeSelectors = require('BeeSelectors');
  // Shared action wrappers with movement intents.
  //var BeeActions = require('BeeActions');
  // Central movement queue; roleQueen enqueues idles here.
  //var MovementManager = require('Movement.Manager');



  // Static configuration covering debug outputs, stuck detection, and movement
  // priorities (higher numbers win when Movement.Manager resolves intents).
 /* var CFG = Object.freeze({
    DEBUG_SAY: false,
    DEBUG_DRAW: true,
    DRAW: {
      WITHDRAW: '#69c3ff',
      DELIVER: '#7dff85',
      PICKUP: '#ffe66e',
      IDLE: '#bfbfbf',
      WIDTH: 0.12,
      OPACITY: 0.45,
      FONT: 0.6
    },
    STUCK_TICKS: 6,
    MOVE_PRIORITIES: {
      withdraw: 60,
      pickup: 70,
      deliver: 55,
      idle: 5
    }
  });
*/
  // Function header: debugSay(creep, msg)
  // Inputs: creep (Creep), msg (string emoji/text)
  // Output: none
  // Side-effects: optionally calls creep.say if CFG.DEBUG_SAY is true.
  // Preconditions: creep must be live in same tick, msg must be printable.
  // Failure modes: silently returns if debugging disabled or creep missing.
  function debugSay(creep, msg) {
    if (CFG.DEBUG_SAY && creep && msg) creep.say(msg, true);
  }

  // Function header: drawLine(creep, target, color, label)
  // Inputs: creep performing work, target (object with pos or RoomPosition),
  //         color hex string, optional label string.
  // Output: none
  // Side-effects: uses RoomVisual to draw intent lines (visible in client when
  //               CFG.DEBUG_DRAW is true).
  // Preconditions: creep.room.visual must exist; target must be visible.
  // Failure modes: try/catch absorbs RoomVisual errors (remote rooms).
  function drawLine(creep, target, color, label) {
    if (!CFG.DEBUG_DRAW || !creep || !target) return;
    var room = creep.room;
    if (!room || !room.visual) return;
    var pos = target.pos || target;
    if (!pos || pos.roomName !== room.name) return;
    try {
      room.visual.line(creep.pos, pos, {
        color: color,
        width: CFG.DRAW.WIDTH,
        opacity: CFG.DRAW.OPACITY,
        lineStyle: 'solid'
      });
      if (label) {
        room.visual.text(label, pos.x, pos.y - 0.3, {
          color: color,
          opacity: CFG.DRAW.OPACITY,
          font: CFG.DRAW.FONT,
          align: 'center'
        });
      }
    } catch (e) {}
  }

  // Function header: ensureTaskSlot(creep)
  // Inputs: creep whose memory we initialise.
  // Output: none
  // Side-effects: ensures creep.memory._task exists (null placeholder) so later
  //               code can read/write without guard checks.
  // Preconditions: creep.memory defined (Screeps always provides an object).
  function ensureTaskSlot(creep) {
    if (!creep || !creep.memory) return;
    if (!creep.memory._task) creep.memory._task = null;
  }

  // Function header: setTask(creep, task)
  // Inputs: creep, task envelope {type,targetId,since,data}
  // Output: none
  // Side-effects: overwrites creep.memory._task; this is persisted in Memory and
  //               survives restarts.
  // Preconditions: ensureTaskSlot should have been called first.
  function setTask(creep, task) {
    if (!creep || !creep.memory) return;
    creep.memory._task = task;
  }

  // Function header: clearTask(creep)
  // Inputs: creep
  // Output: none
  // Side-effects: resets creep.memory._task to null; next tick needsNewTask will
  //               select a new job.
  function clearTask(creep) {
    if (!creep || !creep.memory) return;
    creep.memory._task = null;
  }

  // Function header: getReservationBucket()
  // Inputs: none
  // Output: object map targetId -> reserved energy (per tick)
  // Side-effects: initialises global.__BHM.queenReservations for this tick; this
  //               cache is reset every tick to prevent long-term drift.
  // Preconditions: global.__BHM may already exist (BeeHiveMind initialises it).
  function getReservationBucket() {
    if (!global.__BHM) global.__BHM = {};
    if (!global.__BHM.queenReservations || global.__BHM.queenReservations.tick !== Game.time) {
      global.__BHM.queenReservations = { tick: Game.time, map: {} };
    }
    return global.__BHM.queenReservations.map;
  }

  // Function header: reserveFill(targetId, amount)
  // Inputs: targetId string, amount number (energy units planned to deliver)
  // Output: none
  // Side-effects: increments same-tick reservation counter so multiple Queens do
  //               not overfill one structure.
  function reserveFill(targetId, amount) {
    if (!targetId || amount <= 0) return;
    var map = getReservationBucket();
    var cur = map[targetId] || 0;
    map[targetId] = cur + amount;
  }

  // Function header: getReserved(targetId)
  // Inputs: targetId string
  // Output: number of energy units previously reserved this tick.
  // Side-effects: none.
  function getReserved(targetId) {
    if (!targetId) return 0;
    var map = getReservationBucket();
    return map[targetId] || 0;
  }

  // Function header: getEnergyStored(target)
  // Inputs: structure/resource with store or energy property.
  // Output: integer energy stored; handles structures with store or legacy energy.
  // Side-effects: none.
  function getEnergyStored(target) {
    if (!target) return 0;
    if (target.store) return target.store[RESOURCE_ENERGY] || 0;
    if (target.energy != null) return target.energy | 0;
    return 0;
  }

  // Function header: getFreeEnergyCapacity(target)
  // Inputs: structure with energyCapacity/store.
  // Output: how much additional energy target can accept.
  // Side-effects: none.
  function getFreeEnergyCapacity(target) {
    if (!target) return 0;
    if (target.store && target.store.getFreeCapacity) {
      return target.store.getFreeCapacity(RESOURCE_ENERGY) || 0;
    }
    if (target.energyCapacity != null) {
      return (target.energyCapacity | 0) - (target.energy | 0);
    }
    return 0;
  }

  // Function header: createTask(type, targetId, data)
  // Inputs: type string, targetId (may be null), extra data payload (object)
  // Output: task envelope stored in creep.memory._task. since=Game.time for
  //         debugging and stale-task detection.
  // Side-effects: none (pure factory).
  function createTask(type, targetId, data) {
    return {
      type: type,
      targetId: targetId || null,
      since: Game.time,
      data: data || {}
    };
  }

  // Function header: getIdleAnchor(creep)
  // Inputs: creep
  // Output: structure used as idle anchor (storage > spawn > controller).
  // Side-effects: none; new RoomPosition created later if needed.
  // Notes: ensures idling near "base" to clear traffic lanes.
  function getIdleAnchor(creep) {
    if (!creep || !creep.room) return null;
    if (creep.room.storage) return creep.room.storage;
    var spawns = creep.room.find(FIND_MY_SPAWNS);
    if (spawns && spawns.length) return spawns[0];
    if (creep.room.controller) return creep.room.controller;
    return null;
  }

  // Function header: createIdleTask(creep)
  // Inputs: creep
  // Output: idle task envelope; task.data.pos stores static location and range.
  // Side-effects: none.
  function createIdleTask(creep) {
    var anchor = getIdleAnchor(creep);
    if (!anchor) return createTask('idle', null, null);
    var pos = anchor.pos || anchor;
    var data = {
      pos: { x: pos.x, y: pos.y, roomName: pos.roomName },
      range: 2
    };
    return createTask('idle', anchor.id || null, data);
  }

  // Function header: needsNewTask(creep, task)
  // Inputs: creep, current task envelope (may be null)
  // Output: boolean true when we must pick a fresh task (target gone, capacity
  //         mismatch, stuck for too long).
  // Side-effects: updates task.data.stuck and last position markers in-memory.
  // Preconditions: task.data is an object (initialised if missing).
  function needsNewTask(creep, task) {
    if (!task) return true;
    var target = task.targetId ? Game.getObjectById(task.targetId) : null;
    if (!task.data) task.data = {};

    if (task.type === 'withdraw') {
      // Withdraw task is invalid if target missing, creep already full, or
      // container depleted; this lets us switch to delivery/idle next tick.
      if (!target) return true;
      if (creep.store.getFreeCapacity(RESOURCE_ENERGY) === 0) return true;
      if (getEnergyStored(target) <= 0) return true;
    } else if (task.type === 'pickup') {
      // Dropped/tombstone tasks expire when energy is gone or creep is full.
      if (!target) return true;
      if (creep.store.getFreeCapacity(RESOURCE_ENERGY) === 0) return true;
      if (target.amount != null && target.amount <= 0) return true;
    } else if (task.type === 'deliver') {
      // Delivery tasks drop once the structure fills or we run out of cargo.
      if (!target) return true;
      if ((creep.store[RESOURCE_ENERGY] || 0) === 0) return true;
      if (getFreeEnergyCapacity(target) === 0) return true;
    } else if (task.type === 'idle') {
      // Always allow idle task to continue unless we have energy to move.
    }

    var data = task.data;
    if (data.lastPosX === creep.pos.x && data.lastPosY === creep.pos.y) {
      // Stuck detection: track consecutive ticks with no movement. Movement
      // priority conflicts (e.g., path blocked) cause us to repick a task, which
      // usually repaths to a new target or idles elsewhere.
      data.stuck = (data.stuck || 0) + 1;
      if (data.stuck >= CFG.STUCK_TICKS) return true;
    } else {
      // Movement happened; reset counter so task continues.
      data.stuck = 0;
      data.lastPosX = creep.pos.x;
      data.lastPosY = creep.pos.y;
    }

    return false;
  }

  // Function header: pickWithdrawTask(creep)
  // Inputs: creep (Queen)
  // Output: task envelope for withdrawing/picking up energy, prioritising drop
  //         loot -> tombstones -> ruins -> containers -> other sources.
  // Side-effects: none (no memory writes besides returned task).
  // Dependencies: BeeSelectors.getEnergySourcePriority (see BeeSelectors.js).
  function pickWithdrawTask(creep) {
    var room = creep.room;
    if (!room) return null;
    // -----------------------------
    // Queen-only preference order
    // Edit this array to change what Queens try first.
    // (If you set creep.memory.energyPref, that will override this list for THAT Queen only.)
    // Common sensible Queen order: battlefield cleanup first, then structured stores.
    var pref = (creep.memory && creep.memory.energyPref && creep.memory.energyPref.length)
    ? creep.memory.energyPref
    :['tomb','ruin','storage','drop','container','terminal','link'];
    // Build a room snapshot once
    var list = BeeSelectors.getEnergySourcePriority(room);
    if (!list || !list.length) return null;

    // Bucket snapshot entries by kind for quick access: { kind -> [targets] }
    var buckets = {};
    for (var i = 0; i < list.length; i++) {
      var e = list[i];
      if (!e || !e.target) continue;
      var k = e.kind || 'unknown';
      if (!buckets[k]) buckets[k] = [];
      buckets[k].push(e.target);
    }
    //walk the Queen's preference order; pick the closest target in the first non-empty bucket
    for (var p = 0; p < pref.length; p++) {
      var kind = pref[p];
      if (kind === 'source') continue; // Queens don't harvest
      var arr = buckets[kind];
      if (!arr || !arr.length) continue;
      // Prefer closest-by-range to reduce walking
      var best = BeeSelectors.selectClosestByRange
      ? BeeSelectors.selectClosestByRange(creep.pos, arr)
      : (function (){
          var win = null, bestD = 9999;
          for (var j = 0; j < arr.length; j++) {
            var t = arr[j];
            var d = creep.pos.getRangeTo(t);
            if (d < bestD) { bestD = d; win = t; }
          }
          return win;
        })();    
      if (!best) continue;
      // Map kind -> task
      if (kind === 'drop')      return createTask('pickup',   best.id, { source: 'drop' });
      if (kind === 'tomb')      return createTask('withdraw', best.id, { source: 'tomb' });
      if (kind === 'ruin')      return createTask('withdraw', best.id, { source: 'ruin' });
      if (kind === 'storage')   return createTask('withdraw', best.id, { source: 'storage' });
      if (kind === 'terminal')  return createTask('withdraw', best.id, { source: 'terminal' });
      if (kind === 'container') return createTask('withdraw', best.id, { source: 'container' });
      if (kind === 'link')      return createTask('withdraw', best.id, { source: 'link' });
      // Unknown kind: safe fallback
      return createTask('withdraw', best.id, { source: kind || 'energy' });
    }
    return null;
  }
  // Function header: pickDeliverTask(creep)
  // Inputs: creep with energy cargo
  // Output: task envelope targeting highest priority sink (spawn/extension,
  //         then tower, then storage/terminal)
  // Side-effects: reserves energy in global.__BHM.queenReservations to avoid
  //               over-assigning same sink; writes to reservation map only.
  // Dependencies: BeeSelectors.findSpawnLikeNeedingEnergy etc.
  function pickDeliverTask(creep) {
    var room = creep.room;
    if (!room) return null;

    var amount = creep.store[RESOURCE_ENERGY] || 0;
    if (amount <= 0) return null;

    var spawnLike = BeeSelectors.findSpawnLikeNeedingEnergy(room);
    var bestSpawn = BeeSelectors.selectClosestByRange(creep.pos, spawnLike);
    if (bestSpawn) {
      var freeSpawn = getFreeEnergyCapacity(bestSpawn);
      if (freeSpawn > getReserved(bestSpawn.id)) {
        // Reserve just enough capacity so later Queens see reduced space.
        var planAmount = Math.min(freeSpawn, amount);
        reserveFill(bestSpawn.id, planAmount);
        return createTask('deliver', bestSpawn.id, { sink: 'spawn' });
      }
    }

    var towers = BeeSelectors.findTowersNeedingEnergy(room);
    var bestTower = BeeSelectors.selectClosestByRange(creep.pos, towers);
    if (bestTower) {
      var freeTower = getFreeEnergyCapacity(bestTower);
      if (freeTower > getReserved(bestTower.id)) {
        var planTower = Math.min(freeTower, amount);
        reserveFill(bestTower.id, planTower);
        return createTask('deliver', bestTower.id, { sink: 'tower' });
      }
    }
    
    if (room.storage) {
      // [1] Gather candidate links near storage (radius 2 is typical; bump to 3 if your layout is spaced)
      var storagePos = room.storage.pos;
      var nearbyLinks = storagePos.findInRange(FIND_MY_STRUCTURES, 2, {
        filter: function (s) {
          return s.structureType === STRUCTURE_LINK;
        }
      });

      // If none are literally adjacent, fall back to "closest link in room" to be safe.
      if (!nearbyLinks || nearbyLinks.length === 0) {
        var allLinks = room.find(FIND_MY_STRUCTURES, {
          filter: function (s) {
            return s.structureType === STRUCTURE_LINK;
          }
        });
        // Choose the link closest to storage as our hub candidate
        if (allLinks && allLinks.length) {
          // If you have BeeSelectors, reuse its range helper for consistency
          // Otherwise, you could do storagePos.findClosestByRange(allLinks)
          nearbyLinks = [BeeSelectors.selectClosestByRange(storagePos, allLinks)];
        }
      }

      // [2] From the candidates, pick the one closest to the Queen (shortest run)
      var hubLink = BeeSelectors.selectClosestByRange(creep.pos, nearbyLinks);

      if (hubLink && hubLink.store) {
        // [3] Compute fill percentage and free space
        var cap  = hubLink.store.getCapacity(RESOURCE_ENERGY) || 0;
        var used = hubLink.store.getUsedCapacity(RESOURCE_ENERGY) || 0;
        var fillPct = cap > 0 ? (used / cap) : 1; // if weird zero-cap, treat as "full" to skip
        var free = cap - used;

        // [4] Only top-off if below 80% and there is real free capacity beyond any existing reservations
        if (cap > 0 && fillPct < 0.80 && free > 0) {
          // Respect your reservation system so multiple Queens don't overfill
          var reserved = getReserved(hubLink.id) || 0;
          var availForPlan = free - reserved;

          if (availForPlan > 0) {
            var planAmount = Math.min(amount, availForPlan);
            reserveFill(hubLink.id, planAmount);
            return createTask('deliver', hubLink.id, { sink: 'link_storage' });
          }
        }
      }
    }


    if (room.storage) {
      var storeFree = room.storage.store.getFreeCapacity(RESOURCE_ENERGY) || 0;
      if (storeFree > 0) {
        // Storage fallback ensures excess energy is banked instead of idling.
        return createTask('deliver', room.storage.id, { sink: 'storage' });
      }
    }

    if (room.terminal) {
      var termFree = room.terminal.store.getFreeCapacity(RESOURCE_ENERGY) || 0;
      if (termFree > 0) {
        return createTask('deliver', room.terminal.id, { sink: 'terminal' });
      }
    }

    return null;
  }

  // Function header: chooseNextTask(creep)
  // Inputs: creep (Queen)
  // Output: new task envelope (withdraw/pickup/deliver/idle)
  // Side-effects: none; pure decision based on current cargo and room state.
  function chooseNextTask(creep) {
    if ((creep.store[RESOURCE_ENERGY] || 0) === 0) {
      var withdrawTask = pickWithdrawTask(creep);
      if (withdrawTask) return withdrawTask;
    } else {
      var deliverTask = pickDeliverTask(creep);
      if (deliverTask) return deliverTask;
    }
    return createIdleTask(creep);
  }

  // Function header: executeTask(creep, task)
  // Inputs: creep, task envelope currently stored in memory
  // Output: none; issues actions via BeeActions.* wrappers and MovementManager.
  // Side-effects: may clearTask (memory mutation), may reserve move intents, may
  //               draw visuals. Branch per task.type ensures accurate action.
  // Failure modes: handles missing targets by clearing and returning.
  function executeTask(creep, task) {
    if (!task) return;
    var target = task.targetId ? Game.getObjectById(task.targetId) : null;
    var priority = CFG.MOVE_PRIORITIES[task.type] || 0;

    if (task.type === 'withdraw') {
      if (!target) { clearTask(creep); return; }
      drawLine(creep, target, CFG.DRAW.WITHDRAW, 'WD');
      debugSay(creep, 'üì•');
      // Calls BeeActions.safeWithdraw (BeeActions.js) which queues move intents
      // via Movement.Manager if not in range.
      var rc = BeeActions.safeWithdraw(creep, target, RESOURCE_ENERGY, { priority: priority, reusePath: 20 });
      if (rc === OK) {
        // When cargo full, release the task to select a delivery target next tick.
        if (creep.store.getFreeCapacity(RESOURCE_ENERGY) === 0) clearTask(creep);
      } else if (rc === ERR_NOT_ENOUGH_RESOURCES || rc === ERR_INVALID_TARGET) {
        // Source dried up or object vanished: clear so we re-scan.
        clearTask(creep);
      }
      return;
    }

    if (task.type === 'pickup') {
      if (!target) { clearTask(creep); return; }
      drawLine(creep, target, CFG.DRAW.PICKUP, 'P');
      debugSay(creep, 'üç™');
      var pc = BeeActions.safePickup(creep, target, { priority: priority, reusePath: 10 });
      if (pc === OK) {
        if (creep.store.getFreeCapacity(RESOURCE_ENERGY) === 0) clearTask(creep);
      } else if (pc === ERR_INVALID_TARGET) {
        clearTask(creep);
      }
      return;
    }

    if (task.type === 'deliver') {
      if (!target) { clearTask(creep); return; }
      drawLine(creep, target, CFG.DRAW.DELIVER, 'DL');
      debugSay(creep, 'üöö');
      // safeTransfer returns OK when energy actually transferred; ERR_FULL when
      // sink already filled by another hauler.
      var tr = BeeActions.safeTransfer(creep, target, RESOURCE_ENERGY, null, { priority: priority, reusePath: 20 });
      if (tr === OK) {
        if ((creep.store[RESOURCE_ENERGY] || 0) === 0) clearTask(creep);
      } else if (tr === ERR_FULL || tr === ERR_INVALID_TARGET) {
        clearTask(creep);
      }
      return;
    }

    if (task.type === 'idle') {
      var pos = task.data && task.data.pos;
      if (!pos) return;
      var anchor = new RoomPosition(pos.x, pos.y, pos.roomName);
      drawLine(creep, anchor, CFG.DRAW.IDLE, 'ID');
      // Idle behaviour simply holds position near anchor, giving way when
      // movement manager reuses path = 30 for stable parking.
      MovementManager.request(creep, anchor, priority, { range: task.data.range || 1, reusePath: 30 });
      return;
    }
  }

  var roleQueen = {
    role: 'Queen',
    // Function header: run(creep)
    // Inputs: Queen creep dispatched from BeeHiveMind role loop.
    // Output: none; drives task selection/execution and updates memory.
    // Side-effects: may call MovementManager.request, BeeActions wrappers, and
    //               mutate creep.memory._task. No return value used by caller.
    // Preconditions: creep.role/task set elsewhere (BeeHiveMind.assignTask).
    // Failure modes: gracefully exits if creep is spawning or invalid.
    run: function (creep) {
      if (!creep || creep.spawning) return;
      ensureTaskSlot(creep);

      var task = creep.memory._task;
      if (needsNewTask(creep, task)) {
        // When stale/invalid, choose a fresh job. chooseNextTask encodes gather ‚Üí
        // deliver ‚Üí idle lifecycle.
        task = chooseNextTask(creep);
        setTask(creep, task);
      }

      task = creep.memory._task;
      if (!task) {
        // Last-resort idle ensures memory slot never empty (prevents null checks).
        setTask(creep, createIdleTask(creep));
        task = creep.memory._task;
      }

      executeTask(creep, task);
    }
  };

  return roleQueen;
})();

roleBeeWorker.Upgrader = (function () {


  /** =========================
   *  Debug toggles & styling
   *  ========================= */
  /*
  var CFG = Object.freeze({
    DEBUG_SAY: false,
    DEBUG_DRAW: true,

    // Behavior knobs
    SKIP_RCL8_IF_SAFE: true,
    RCL8_SAFE_TTL: 180000, // ticksToDowngrade threshold to pause at RCL8
    TRAVEL_REUSE: 16,

    // Visual palette
    DRAW: {
      PATH:   "#8ab6ff",
      CTRL:   "#ffd16e",
      LINK:   "#9cff9c",
      STORE:  "#b0a7ff",
      CONT:   "#8ef",
      DROP:   "#ffb27a",
      TEXT:   "#e0e0e0",
      WIDTH:  0.12,
      OPAC:   0.45,
      FONT:   0.7
    },

    SIGN_TEXT: "BeeNice Please."
  });
*/
  /** =========================
   *  Tiny debug helpers
   *  ========================= */
  function debugSay(creep, msg) {
    if (CFG.DEBUG_SAY && creep && typeof creep.say === 'function') creep.say(msg, true);
  }
  function _posOf(t) { return t && t.pos ? t.pos : t; }
  function _roomOf(pos) { return pos && Game.rooms[pos.roomName]; }

  function debugLine(from, to, color) {
    if (!CFG.DEBUG_DRAW || !from || !to) return;
    var f = _posOf(from), t = _posOf(to);
    if (!f || !t || f.roomName !== t.roomName) return;
    var R = _roomOf(f); if (!R || !R.visual) return;
    R.visual.line(f, t, { color: color, width: CFG.DRAW.WIDTH, opacity: CFG.DRAW.OPAC });
  }
  function debugRing(target, color, text) {
    if (!CFG.DEBUG_DRAW || !target) return;
    var p = _posOf(target); if (!p) return;
    var R = _roomOf(p); if (!R || !R.visual) return;
    R.visual.circle(p, { radius: 0.6, fill: "transparent", stroke: color, opacity: CFG.DRAW.OPAC, width: CFG.DRAW.WIDTH });
    if (text) R.visual.text(text, p.x, p.y - 0.8, { color: color, font: CFG.DRAW.FONT, opacity: 0.95, align: "center" });
  }

  /** =========================
   *  Travel wrapper (with path line)
   *  ========================= */
  function go(creep, dest, range) {
    var R = (range != null) ? range : 1;
    var dpos = _posOf(dest) || dest;
    if (creep.pos.roomName === dpos.roomName && creep.pos.getRangeTo(dpos) > R) {
      debugLine(creep.pos, dpos, CFG.DRAW.PATH);
    }
    if (creep.pos.getRangeTo(dpos) <= R) return OK;

    try {
      if (BeeToolbox && typeof BeeToolbox.BeeTravel === 'function') {
        return BeeToolbox.BeeTravel(creep, dpos, { range: R, reusePath: CFG.TRAVEL_REUSE });
      }
    } catch (e) {}
    if (typeof creep.travelTo === 'function') {
      return creep.travelTo(dpos, { range: R, reusePath: CFG.TRAVEL_REUSE, ignoreCreeps: false, maxOps: 4000 });
    }
    return creep.moveTo(dpos, { reusePath: CFG.TRAVEL_REUSE, maxOps: 1500 });
  }

  /** =========================
   *  Sign helper (unchanged logic, plus visuals)
   *  ========================= */
  function checkAndUpdateControllerSign(creep, controller) {
    if (!controller) return;
    var msg = CFG.SIGN_TEXT;

    var needs = (!controller.sign) || (controller.sign.text !== msg);
    if (!needs) return;

    if (creep.pos.inRangeTo(controller.pos, 1)) {
      var res = creep.signController(controller, msg);
      if (res === OK) {
        debugSay(creep, "üñäÔ∏è");
        debugRing(controller, CFG.DRAW.CTRL, "signed");
        console.log("Upgrader " + creep.name + " updated the controller sign.");
      } else {
        console.log("Upgrader " + creep.name + " failed to update the controller sign. Error: " + res);
      }
    } else {
      debugSay(creep, "üìù");
      debugLine(creep, controller, CFG.DRAW.CTRL);
      go(creep, controller, 1);
    }
  }

  function pickDroppedEnergy(creep) {
    var targetDroppedEnergyId = creep.memory.targetDroppedEnergyId;
    var droppedResource = targetDroppedEnergyId ? Game.getObjectById(targetDroppedEnergyId) : null;
    if (!droppedResource) {
      droppedResource = creep.pos.findClosestByPath(FIND_DROPPED_RESOURCES, {
        filter: function (r) {
          return r.resourceType === RESOURCE_ENERGY && r.amount > 0;
        }
      });
      if (droppedResource) {
        creep.memory.targetDroppedEnergyId = droppedResource.id;
      }
    }
    if (droppedResource) {
      debugRing(droppedResource, CFG.DRAW.DROP, 'drop');
      debugLine(creep, droppedResource, CFG.DRAW.DROP);
      var pr = creep.pickup(droppedResource);
      if (pr === ERR_NOT_IN_RANGE) {
        go(creep, droppedResource, 1);
      } else if (pr === OK) {
        debugSay(creep, "üì¶");
        creep.memory.targetDroppedEnergyId = null;
      }
      return true;
    }
    creep.memory.targetDroppedEnergyId = null;
    return false;
  }

  // =========================
  // Main role
  // =========================
  return {
    role: 'Upgrader',

    run: function (creep) {
      if (!creep) return;
      ensureRoleIdentity(creep);
      toggleUpgradingState(creep);

      if (creep.memory.upgrading) {
        runUpgradePhase(creep);
        return;
      }
      runRefuelPhase(creep);
    }
  };

  function ensureRoleIdentity(creep) {
    if (creep.memory && !creep.memory.role) creep.memory.role = 'Upgrader';
  }

  function toggleUpgradingState(creep) {
    if (creep.memory.upgrading && creep.store[RESOURCE_ENERGY] === 0) {
      creep.memory.upgrading = false;
      creep.memory.targetDroppedEnergyId = null;
      debugSay(creep, "üîÑ refuel");
    } else if (!creep.memory.upgrading && creep.store.getFreeCapacity() === 0) {
      creep.memory.upgrading = true;
      debugSay(creep, "‚ö° upgrade");
    }
  }

  function runUpgradePhase(creep) {
    var controller = creep.room.controller;
    if (!controller) return;

    if (shouldPauseAtSafeRCL8(controller)) {
      checkAndUpdateControllerSign(creep, controller);
      debugSay(creep, "‚è∏");
      debugRing(controller, CFG.DRAW.CTRL, "safe");
      return;
    }

    var ur = creep.upgradeController(controller);
    if (ur === ERR_NOT_IN_RANGE) {
      debugLine(creep, controller, CFG.DRAW.CTRL);
      go(creep, controller, 3);
    } else if (ur === OK) {
      debugRing(controller, CFG.DRAW.CTRL, "UP");
    }
    checkAndUpdateControllerSign(creep, controller);
  }

  function shouldPauseAtSafeRCL8(controller) {
    if (!CFG.SKIP_RCL8_IF_SAFE) return false;
    if (controller.level !== 8) return false;
    return (controller.ticksToDowngrade | 0) > CFG.RCL8_SAFE_TTL;
  }

  function runRefuelPhase(creep) {
    if (tryLinkPull(creep)) return;
    tryToolboxSweep(creep);
    if (tryWithdrawStorage(creep)) return;
    if (tryWithdrawContainer(creep)) return;
    if (pickDroppedEnergy(creep)) return;
    if (CFG.DEBUG_DRAW) debugSay(creep, "‚ùì");
  }

  function tryLinkPull(creep) {
    var ctrl = creep.room.controller;
    if (!ctrl) return false;
    var linkNearController = creep.pos.findClosestByRange(FIND_STRUCTURES, {
      filter: function (s) {
        return s.structureType === STRUCTURE_LINK &&
          s.store && (s.store[RESOURCE_ENERGY] | 0) > 0 &&
          s.pos.inRangeTo(ctrl, 3);
      }
    });
    if (!linkNearController) return false;
    var lr = creep.withdraw(linkNearController, RESOURCE_ENERGY);
    debugRing(linkNearController, CFG.DRAW.LINK, "LINK");
    debugLine(creep, linkNearController, CFG.DRAW.LINK);
    if (lr === ERR_NOT_IN_RANGE) go(creep, linkNearController, 1);
    return true;
  }

  function tryToolboxSweep(creep) {
    try {
      if (BeeToolbox && typeof BeeToolbox.collectEnergy === 'function') {
        BeeToolbox.collectEnergy(creep);
      }
    } catch (e) {}
  }

  function tryWithdrawStorage(creep) {
    var stor = creep.room.storage;
    if (!stor || !stor.store || (stor.store[RESOURCE_ENERGY] | 0) <= 0) return false;
    debugRing(stor, CFG.DRAW.STORE, "STO");
    debugLine(creep, stor, CFG.DRAW.STORE);
    var sr = creep.withdraw(stor, RESOURCE_ENERGY);
    if (sr === ERR_NOT_IN_RANGE) go(creep, stor, 1);
    return true;
  }

  function tryWithdrawContainer(creep) {
    var containerWithEnergy = creep.pos.findClosestByPath(FIND_STRUCTURES, {
      filter: function (s) {
        return s.structureType === STRUCTURE_CONTAINER &&
          s.store && (s.store[RESOURCE_ENERGY] | 0) > 0;
      }
    });
    if (!containerWithEnergy) return false;
    debugRing(containerWithEnergy, CFG.DRAW.CONT, "CONT");
    debugLine(creep, containerWithEnergy, CFG.DRAW.CONT);
    var cr = creep.withdraw(containerWithEnergy, RESOURCE_ENERGY);
    if (cr === ERR_NOT_IN_RANGE) go(creep, containerWithEnergy, 1);
    return true;
  }
})();

roleBeeWorker.handlers = {
  BaseHarvest: roleBeeWorker.BaseHarvest,
  Builder: roleBeeWorker.Builder,
  Courier: roleBeeWorker.Courier,
  Queen: roleBeeWorker.Queen,
  Upgrader: roleBeeWorker.Upgrader
};

roleBeeWorker.run = function run(creep, explicitRole) {
  if (!creep) return;
  var roleName = explicitRole;
  if (!roleName && creep.memory) {
    roleName = creep.memory.role || creep.memory.task;
  }
  if (!roleName) return;
  var handler = roleBeeWorker.handlers[roleName];
  if (!handler || typeof handler.run !== 'function') return;
  return handler.run(creep);
};

roleBeeWorker.runBaseHarvest = function(creep) { return roleBeeWorker.BaseHarvest.run(creep); };
roleBeeWorker.runBuilder = function(creep) { return roleBeeWorker.Builder.run(creep); };
roleBeeWorker.runCourier = function(creep) { return roleBeeWorker.Courier.run(creep); };
roleBeeWorker.runQueen = function(creep) { return roleBeeWorker.Queen.run(creep); };
roleBeeWorker.runUpgrader = function(creep) { return roleBeeWorker.Upgrader.run(creep); };

if (roleBeeWorker.Builder && roleBeeWorker.Builder.structurePlacements) {
  roleBeeWorker.structurePlacements = roleBeeWorker.Builder.structurePlacements;
}

module.exports = roleBeeWorker;
